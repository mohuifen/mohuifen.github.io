<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[秋儿]]></title>
  <subtitle><![CDATA[iOS 开发]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com//"/>
  <updated>2016-03-29T11:24:57.000Z</updated>
  <id>http://yoursite.com//</id>
  
  <author>
    <name><![CDATA[秋儿]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Block]]></title>
    <link href="http://yoursite.com/2016/03/29/Block/"/>
    <id>http://yoursite.com/2016/03/29/Block/</id>
    <published>2016-03-29T11:23:19.000Z</published>
    <updated>2016-03-29T11:24:57.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<p><code>Blocks：</code></p>
<p>C 语言的扩充功能。带有自动变量（局部变量）的匿名函数。</p>
<p>匿名函数：不带名称的函数。C 语言的标准不允许存在这样的函数，但可以使用函数的指针来代替直接调用函数。</p>
<p>Blocks 中将该匿名函数部分称为 “Block Literal”，简称 “BlocK”。</p>
<p>“带有自动变量的匿名函数” 这一概念并不仅指 Blocks ，在计算机科学中，也称为闭包（Closure）、lambda 计算（lambda calculus）等。</p>
<table>
<thead>
<tr>
<th>程序语言</th>
<th>Block 的名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>C + Blocks</td>
<td>Block</td>
</tr>
<tr>
<td>Smalltalk</td>
<td>BlocK</td>
</tr>
<tr>
<td>Ruby</td>
<td>Block</td>
</tr>
<tr>
<td>LISP</td>
<td>Lambda</td>
</tr>
<tr>
<td>Python</td>
<td>Lambda</td>
</tr>
<tr>
<td>C++ 11</td>
<td>Lambda</td>
</tr>
<tr>
<td>Javascript</td>
<td>Anonymous function</td>
</tr>
</tbody>
</table>
<p><code>Block 语法：</code></p>
<p>与 C 语言函数 定义相比有两点不同：</p>
<ul>
<li>没有函数名</li>
<li>带有 “^”， 插入记号，便于查找</li>
</ul>
<pre><code>^ void (int event) {
    printf(&quot;buttonId:%d event=%d\n&quot;,i,event);
}
</code></pre><a id="more"></a>
<p>Block 语法的 BN范式：</p>
<pre><code>Block_literal_expression :: = ^ block_decl compound_statement_body
block_decl ::=
block_decl ::= parameter_list
block_decl ::= type_expression
</code></pre><p><strong>^ 返回值类型 参数列表 表达式</strong></p>
<pre><code>^init (init count){ return count +1;}
</code></pre><p>Block 语法可省略的几个项目：</p>
<ul>
<li><p>返回值：如果表达式中有 return 语句，就使用该返回值的类型，拖过没有 return 则使用 void 类型。 </p>
<pre><code>^(int count){return count + 1;}// 返回 int 型返回值 
</code></pre></li>
<li><p>参数列表：</p>
<pre><code>^void (void){printf(&quot;Blocks\n&quot;);}
^{printf(&quot;Blocks\n&quot;);}// 与上面代码等价
</code></pre></li>
</ul>
<p><code>Block 类型变量：</code></p>
<p>C 语言函数，将所定义函数的地址赋值给函数指针类型变量中。</p>
<pre><code>int func (ini count) {
    return count + 1;
}
int (* funcptr)(int) = &amp;func;
</code></pre><p>Block 类型变量示例：</p>
<pre><code>int (^blk)(init);
</code></pre><p>对比可知：声明 Block 类型变量仅仅是将声明函数指针类型变量 的 * 变为 ^</p>
<p>Block 语法将 Block 赋值为Block 类型变量</p>
<pre><code>int (^blk)(int) = ^(ini count){
    return count +1;
} 

int (^blk1)(int) = blk;
int (^blk2)(int);
blk2 = blk1;

// 将 Block 作为参数
void func(int (^blk)(init)){}

// 将 Block 作为返回值
int (^func()(int)) {
    return ^(int count){
         return count + 1;
    }
}
</code></pre><p>使用 typedef 来解决 函数参数和返回值中使用Block 类型变量太复杂的问题。</p>
<pre><code>typedef int (^blk_t)(int);

void func(blk_t blk) {}

blk_t func() {}
</code></pre><p>调用函数的方法与使用函数指针变量调用函数的方法相同：</p>
<pre><code>int result = (*funcptr)(10);

int result = blk(10);
</code></pre><p>指向 Block 类型变量的指针，即 Block 的指针类型变量</p>
<pre><code>typedef int (^blk_t)(int);
blk_t blk = ^(int count){ return count +1;};
blk_t *blkptr = &amp;blk ;
(*blkptr)(10);
</code></pre><p><code>截获自动变量值：</code></p>
<pre><code>int main(){
    int dmy = 256;
    int val = 10;
    const char *fmt = &quot;val = %d\n&quot;;
    void (^blk)(void) = ^{printf(fmt,val);};

    val = 2；
    fmt =&quot;These values were changed. val = %d\n&quot;;

    blk();// val = 10;
    return 0;
}
</code></pre><p><code>__block 说明符：</code></p>
<p>若想在 Block 语法表达式中将 Block 语法外声明的自动变量的值进行改写，则该自动变量需加上 __block 说明符。</p>
<pre><code>__block int val = 0;
void (^blk)(void) =^{ val = 1};
blk();
// val = 1;
</code></pre><p><code>截获的自动变量：</code></p>
<p>不加 __block 说明符，使用截获的自动变量不会出错，但赋值给截获的自动变量会编译错误：</p>
<pre><code>id array = [[NSMutableArray alloc] init];
void (^blk)(void) = ^{
    id obj = [[NSObject alloc] init];
    [array addObject:obj]; // 不会出错
    array = [[NSMutableArray alloc] init]; // 编译错误， 需在外面的array 声明的地方添加 __block 说明符

}
</code></pre><p>在使用 C 语言数组时必须小心使用其指针，在 Blocks 中，截获自动变量的方法并没有实现对 C 语言数组的截获，应使用指针解决。</p>
<pre><code>// 不正确
const char text[] = &quot;hello&quot;;
void (^blk)(void) = ^{
    printf(&quot;%c\n&quot;,text[2]);
};

// 正确
const char *text[] = &quot;hello&quot;;
void (^blk)(void) = ^{
    printf(&quot;%c\n&quot;,text[2]);
};
</code></pre><p><code>Blocks 的实现：</code></p>
<p>Block 实际上是作为极普通的 C 语言源代码来处理的。通过支持 Block 的编译器，含有 Block 语法的源代码转换为一般的 C 语言编译器能够处理的源代码，然后被编译。</p>
<p>将含有 Block 语法的源代码变换为 C++ 的源代码。仅使用了 struct 结构， 本质是 C 语言源代码。</p>
<pre><code>clang -rewrite-objc 源代码文件名
</code></pre><blockquote>
<p>各种实现方式，现在无法理解，之后再补。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<p><code>Blocks：</code></p>
<p>C 语言的扩充功能。带有自动变量（局部变量）的匿名函数。</p>
<p>匿名函数：不带名称的函数。C 语言的标准不允许存在这样的函数，但可以使用函数的指针来代替直接调用函数。</p>
<p>Blocks 中将该匿名函数部分称为 “Block Literal”，简称 “BlocK”。</p>
<p>“带有自动变量的匿名函数” 这一概念并不仅指 Blocks ，在计算机科学中，也称为闭包（Closure）、lambda 计算（lambda calculus）等。</p>
<table>
<thead>
<tr>
<th>程序语言</th>
<th>Block 的名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>C + Blocks</td>
<td>Block</td>
</tr>
<tr>
<td>Smalltalk</td>
<td>BlocK</td>
</tr>
<tr>
<td>Ruby</td>
<td>Block</td>
</tr>
<tr>
<td>LISP</td>
<td>Lambda</td>
</tr>
<tr>
<td>Python</td>
<td>Lambda</td>
</tr>
<tr>
<td>C++ 11</td>
<td>Lambda</td>
</tr>
<tr>
<td>Javascript</td>
<td>Anonymous function</td>
</tr>
</tbody>
</table>
<p><code>Block 语法：</code></p>
<p>与 C 语言函数 定义相比有两点不同：</p>
<ul>
<li>没有函数名</li>
<li>带有 “^”， 插入记号，便于查找</li>
</ul>
<pre><code>^ void (int event) {
    printf(&quot;buttonId:%d event=%d\n&quot;,i,event);
}
</code></pre>]]>
    
    </summary>
    
      <category term="Block" scheme="http://yoursite.com/tags/Block/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARC规则]]></title>
    <link href="http://yoursite.com/2016/03/17/ARC%E8%A7%84%E5%88%99/"/>
    <id>http://yoursite.com/2016/03/17/ARC规则/</id>
    <published>2016-03-17T08:49:05.000Z</published>
    <updated>2016-03-17T09:11:55.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<blockquote>
<p>学习笔记 二 之《Objective-C高级编程 iOS与OS X多线程和内存管理》</p>
</blockquote>
<h5 id="u7B2C_u4E00_u7AE0_uFF1A_u81EA_u52A8_u5F15_u7528_u8BA1_u6570"><a href="#u7B2C_u4E00_u7AE0_uFF1A_u81EA_u52A8_u5F15_u7528_u8BA1_u6570" class="headerlink" title="第一章：自动引用计数"></a>第一章：自动引用计数</h5><p><strong>ARC 规则</strong></p>
<p><code>ARC 所有权修饰符：</code></p>
<ul>
<li><p>__strong：</p>
<p>  对对象强引用，变量超出其作用域时被废弃，强引用失效，对象也随之释放（id 类型和对象类型默认为 __strong 修饰符）</p>
</li>
<li><p>__weak：</p>
</li>
</ul>
<a id="more"></a>
<pre><code>在持有某对象的弱引用时，若对象被废弃，则此弱引用将自动失效且处于nil 被赋值的状态（空弱引用）。只能用于 iOS5 和 OS X Lion 以上版本，以下可使用 __unsafe_unretained 修饰符来代替。 
</code></pre><ul>
<li><p>__unsafe_unretained：</p>
<p>  被修饰的变量不属于编译器的内存管理对象，是 __weak 的代替</p>
</li>
<li><p>__autoreleasing：</p>
<p>  @autoreleasepool 块代替 NSAutoreleasePool 类对象生成，持有，废弃这一范围</p>
<p>  __autoreleasing 修饰符 等价于在 ARC 无效时调用对象的 autorelease 方法</p>
<p>  编译器会检查方法名是否是以 alloc/new/copy/mutableCopy 开始，不是，则自动将返回值得对象注册到 autoreleasepool</p>
<p>  访问 __weak 修饰符的变量时必须访问注册到 autoreleasepool 的对象</p>
<p>  id 的指针或对象的指针会默认附加上 __autoreleasing 修饰符</p>
<p>  赋值给对象指针时，所有权修饰符必须一致：</p>
<pre><code>NSError *error = nil;
NSError * __strong *pError = &amp;error;

NSError _weak *error = nil;
NSError * __weak *pError = &amp;error;
</code></pre><p>  NSRunLoop 等实现不论 ARC 有效还是无效，均能够随时释放注册到 autoreleasepool 中的对象。</p>
<p>  ARC 无效时 @autoreleasepool 块 _objc_autoreleasePoolPrint() 均能使用。</p>
</li>
</ul>
<p><code>ARC 规则：</code>    </p>
<ul>
<li><p>不能使用 retain/release/retainCount/autorelease：</p>
<p>  内存管理是编译器的工作</p>
</li>
<li><p>不能使用 NSAllocateObject/NSDeallocateObject</p>
</li>
<li><p>需遵守内存管理的方法命名规则：</p>
<p>  init 开始的方法返回的对象并不注册到autoreleasepool 上</p>
<p>  init 方法返回的对象应为 id 类型或该方法声明类的对象类型，或者是该类的超类型或子类型</p>
</li>
<li><p>不要显式调用 dealloc</p>
</li>
<li>使用 @autoreleasepool 块替代 NSAutoreleasePool</li>
<li><p>不能使用区域（NSZone）：</p>
<p>  不管 ARC 是否有效，区域在现在的运行时系统中已单纯的被忽略</p>
</li>
<li><p>对象型变量不能作为 C 语言结构体（struct/union）的成员：</p>
<p>  要把对象型变量加入到结构体成员中时，可强制转换为 void * 或者是附加 __unsafe_unretained 修饰符</p>
<pre><code>struct Data {
    NSMutableArray __unsafe_unretained *array;
};
</code></pre></li>
<li><p>显式转换 “id” 和 “void *”</p>
<p>  在 ARC 无效时，将 void * 变量赋值给 id 变量，调用其实例方法，运行时不会有问题</p>
<pre><code>//ARC 无效
id obj = [[NSObject alloc] init];
void *p = obj;
id o = p;
[o release];
</code></pre><p>  在 ARC 有效时，上面的代码会引起编译错误。id 型或对象型变量赋值给 void * 或者逆向赋值时都需要进行特定的转换。如果只想单纯地赋值，则可以使用 “__bridge 转换”</p>
<pre><code>id obj = [[NSObject alloc] init];
void *p = (__bridge void *)obj;
id o = (__bridge id)p;
</code></pre><p>  转换为 void * 的 <strong>bridge 转换，其安全性与赋值给 </strong>unsafe_unretained 修饰符相近，甚至更低。如果管理时不注意赋值对象的所有者，就会因悬垂指针而导致程序崩溃。</p>
<p>  <strong>bridge 转换中还有 “</strong>bridge_retained 转换” 和 “__bridge_transfer转换”</p>
<ul>
<li>__bridge_retained 使要转换赋值的变量也持有所赋值的对象， 与retain 相似</li>
<li>__bridge_transfer 与上面的相反，被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放，与 release 相似</li>
</ul>
</li>
</ul>
<pre><code>Objective-C 对象和 Core Foundation 对象，后者主要使用在用 C 语言编写的 Core Foundation 框架中，使用引用计数的对象。两者区别很小，不同之处只在于由哪一个框架所生成。一旦生成，便能在不同的框架中使用。


    CFMutableArrayRef cgObject = NULL;
    {
        id obj = [[NSMutableArray alloc] init];
        cfObject = CFBridgeRetain(obj);
        CFShow(cfObject);
        printf(&quot;retain count = %d\n&quot;,CFGetRetainCount(cfObject));// 2
    }
    printf(&quot;retain count after scope = %d\n&quot;,CFGetRetainCount(cfObject));// 1
    CFRelease（cfObject）;

__bridge_retained 转换 可以代替 CFBridgeRetain，当然，__bridge_transfer 转换也可以替代 CFBridgeRelease
</code></pre><p><code>属性：</code></p>
<table>
<thead>
<tr>
<th>属性声明的属性</th>
<th>所有权修饰符      </th>
</tr>
</thead>
<tbody>
<tr>
<td> assin</td>
<td>__unsafe_unretained 修饰符      </td>
</tr>
<tr>
<td> copy</td>
<td>__strong 修饰符（但是赋值的是被复制的对象）</td>
</tr>
<tr>
<td> retain</td>
<td>__strong 修饰符</td>
</tr>
<tr>
<td> strong</td>
<td>__strong 修饰符</td>
</tr>
<tr>
<td> unsafe_unretained</td>
<td>__unsafe_unretained 修饰符</td>
</tr>
<tr>
<td> weak</td>
<td>__weak 修饰符</td>
</tr>
</tbody>
</table>
<p>声明类成员变量时，如果同属性声明中的属性不一致，则会引起编译错误，如：</p>
<pre><code>// 错误
id obj;
@property (nonatomic, weak) id obj;


// 正确
id __weak obj;
@property (nonatomic, weak) id obj;

// 正确
id obj;
@property (nonatomic, strong) id obj;
</code></pre><p><code>数组：</code></p>
<p>数组超出其变量作用域时，数组中各个附有 __strong 修饰符的变量也随之失效，其强引用消失，对象随之释放。</p>
<ul>
<li>calloc 函数分配内存会使分配区域初始化为0</li>
<li>malloc 函数分配内存后区域没有被初始化0，可用 memset 等函数将内存填充为 0 </li>
</ul>
<p><code>ARC 的实现：</code></p>
<p>ARC 是由编译器进行内存管理，但是需要 Objective-C 运行时库的协助</p>
<ul>
<li>clang(LLVM 编译器)3.0 以上</li>
<li>objc4 Objective-C 运行时库 493.9 以上</li>
</ul>
<p>以下内容待学</p>
<p><code>__strong 修饰符：</code></p>
<p><code>__weak 修饰符：</code></p>
<p><code>__autoreleasing 修饰符：</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<blockquote>
<p>学习笔记 二 之《Objective-C高级编程 iOS与OS X多线程和内存管理》</p>
</blockquote>
<h5 id="u7B2C_u4E00_u7AE0_uFF1A_u81EA_u52A8_u5F15_u7528_u8BA1_u6570"><a href="#u7B2C_u4E00_u7AE0_uFF1A_u81EA_u52A8_u5F15_u7528_u8BA1_u6570" class="headerlink" title="第一章：自动引用计数"></a>第一章：自动引用计数</h5><p><strong>ARC 规则</strong></p>
<p><code>ARC 所有权修饰符：</code></p>
<ul>
<li><p>__strong：</p>
<p>  对对象强引用，变量超出其作用域时被废弃，强引用失效，对象也随之释放（id 类型和对象类型默认为 __strong 修饰符）</p>
</li>
<li><p>__weak：</p>
</li>
</ul>]]>
    
    </summary>
    
      <category term="Objective-C高级编程 iOS与OS X多线程和内存管理" scheme="http://yoursite.com/tags/Objective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-iOS%E4%B8%8EOS-X%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[内存管理和引用计数]]></title>
    <link href="http://yoursite.com/2016/03/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2016/03/15/内存管理和引用计数/</id>
    <published>2016-03-15T09:35:11.000Z</published>
    <updated>2016-03-15T09:51:57.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<blockquote>
<p>学习笔记 一 之《Objective-C高级编程 iOS与OS X多线程和内存管理》</p>
</blockquote>
<h5 id="u7B2C_u4E00_u7AE0_uFF1A_u81EA_u52A8_u5F15_u7528_u8BA1_u6570"><a href="#u7B2C_u4E00_u7AE0_uFF1A_u81EA_u52A8_u5F15_u7528_u8BA1_u6570" class="headerlink" title="第一章：自动引用计数"></a>第一章：自动引用计数</h5><p><strong>内存管理/引用计数</strong></p>
<p><code>ARC 使用条件：</code></p>
<p>Xcode4.2，LLVM3.0，编译器设置 ARC 有效</p>
<p><code>引用计数：</code></p>
<p>1.自己生成的对象，自己所持有（alloc，new，copy，mutableCopy，allocMyObject，newThatObject，copyThis，mutableCopyYourObject）:</p>
<ul>
<li>alloc：自己生成并持有对象</li>
<li>new：自己生成并持有对象</li>
<li>copy：利用 NSCopying，各类实现 copyWithZone: 生成并持有对象的副本</li>
<li>mutableCopy：利用 NSMutableCopying,各类实现 mutableCopyWithZone: 生成并持有对象的副本</li>
</ul>
<a id="more"></a>
<p>2.非自己生成的对象，自己也能持有（retain）:</p>
<ul>
<li>通过 retain 方法，非自己生成的对象跟 alloc/new/copy/mutableCopy 方法生成并持有的对象一样，成为了自己所持有的</li>
</ul>
<p>3.不再需要自己持有的对象时释放（release）:</p>
<ul>
<li>release：自己持有的对象，一旦不再需要，持有者有义务释放该对象。</li>
<li>autorelease： 不立即释放，注册到autoreleasepool 中，pool 结束时自动调用release</li>
</ul>
<p>4.非自己持有的对象无法释放：</p>
<ul>
<li>释放非自己持有的对象会造成程序崩溃</li>
</ul>
<p><code>GNUstep：</code></p>
<p>是 Cocoa 框架的互换框架，两者的行为和实现方式非常相似。</p>
<p><code>alloc/retain/release/dealloc 实现：</code></p>
<p>1.alloc：</p>
<pre><code>+ (id)alloc {
    return [self allocWithZone: NSDefaultMallocZone()];
}
+ (id)allocWithZone:(NSZone *)z { 
    return NSAllocateObject(self, 0, z);
}
</code></pre><p>NSAllocateObject 函数分配对象</p>
<pre><code>struct obj_layout {
    NSUInteger retained;
}
inline id 
NSAllocateObject(Class aClass, NSUInteger extraBytes, NSZone *zone) {
    int size = 计算容纳对象所需内存的大小;
    id new = NSZoneMalloc(zone, size);// 分配存放对象所需的内存空间
    memset(new, 0, size);// 将该内存空间置为0
    new = (id) &amp;((struct obj_layout *) new)[1];// 返回作为对象而使用的指针。
}
</code></pre><p>NSDefaultMallocZone、NSZoneMalloc 中的 NSZone， 为防止内存碎片化而引入的结构。根据使用对象的目的、对象的大小 分配内存，提高内存管理的效率。 </p>
<p>多重区域防止内存碎片化。</p>
<p>去掉NSZone 后简化的源代码：</p>
<pre><code>struct obj_layout {
    NSUInteger retained;// 保存引用计数，写入对象内存头部，
}
+ (id)alloc {
    int size = sizeof(struct obj_layout) + 对象大小；
    struct obj_layout *p = (struct obj_layout *)calloc(1, size);
    return (id)(p+1);
}
</code></pre><p>对象的引用计数可通过 retainCount 实例方法取得</p>
<pre><code>id obj = [[NSObject alloc] init];
NSLog(@&quot;retainCount = %d&quot;, [obj retainCount]);


// NSObject.m
- (NSUInteger)retainCount {
    return NSExtraRefCount(self) + 1;
}

inline NSUInteger 
NSExtraRefCount(id anObject) {
    return ((struct obj_layout *) anObject)[-1].retained;// 由对象寻址找到对象内存头部，访问retained 变量
}
</code></pre><p>2.retain<br>I</p>
<pre><code>//NSObject.m
- (id)retain {
    NSIncrementExtraRefCount(self);
    return self;
}

inline void
NSIncrementExtraRefCount(id anObject) {
// 当 retained 变量 超出最大值时发生异常
    if ((struct obj_layout *)anObject)[-1].retained == UINT_MAX     - 1) {
        [NSException raise:NSInternalInconsistencyException format:@&quot;NSIncrementExtraRefCount() asked to increment too far&quot;];
    }
    ((sruct obj_layout *)anObject)[-1].retained++;
}
</code></pre><p>3.release </p>
<pre><code>//NSObject.m
- (void)release {
    if(NSDecrementExtraRefCountWasZero(self)) {
    [self dealloc];
}

inline BOOL
NSDecrementExtraRefCount(id anObject) {
    //    当retained 变量大于 0 时 减 1， 等于 0 时调用 dealloc 实例方法，废弃对象
    if(((struct obj_layout *)anObject)[-1].retained == 0 ) {
        return YES;
    } else {
        ((struct obj_layout *)anObject)[-1].retained--;
        return NO;
    }
})
</code></pre><p>4.dealloc </p>
<pre><code>//NSObject.m
- (void)dealloc {
    NSDeallocateObject(self);
}

inline void
NSDeallocateObject(id anObject) {
    struct obj_layout *o = &amp;((struct obj_layout *)anObject)[-1];
    free(0);// 仅废弃由 alloc 分配的内存块
}
</code></pre><p><code>苹果的实现：</code></p>
<p>1.alloc</p>
<pre><code>+alloc
+allocWithZone:
class_createInstance
calloc
</code></pre><p>2.retainCount</p>
<pre><code>-retainCount
__CFDoExterRefOperation
CFBaseicHashGetCountOfKey
</code></pre><p>3.retain</p>
<pre><code>-retain
__CFDoExterRefOperation
CFBasicHashAddValue
</code></pre><p>4.release</p>
<pre><code>-release
__CFDoExterRefOperation
CFBasicHashRemoveValue
(CFBasicHashRemoveValue 返回 0  时，-release 调用 dealloc)


//CFRuntime.c __CFDoExterRefOperation
int __CFDoExterRefOperation(uintptr_r op, id obj) {
    CFBasicHashRef table = 取得对象对应的散列表（obj）;
    int count;

    switch(op) {
        case OPERATION_retainCount:
            count = CFBasicHashGetCountOfKey(table, obj);
            return count;
        case OPERATION_retain:
            CFBasicHashAddValue(table, obj);
            return obj;
        case OPERATION_release:
            count = CFBasicHashRemoveValue(table, obj);
            return 0 == count;
    }
}
</code></pre><p>苹果的实现大概就是采用散列表（引用计数表）来管理引用计数</p>
<p>1.GNUstep 引用计数保存在对象占用内存块头部的变量中，好处：</p>
<ul>
<li>少量代码即可完成</li>
<li>能够统一管理引用计数用内存块与对象内存块</li>
</ul>
<p>2.苹果     引用计数保存在引用计数表的记录中，好处：</p>
<ul>
<li>对象用内存块的分配无需考虑内存块头部</li>
<li>引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块</li>
</ul>
<p>出现故障导致对象占用的内存块损坏，但只要引用计数表没有被破坏，就能够确认内存块的位置；应用计数表有助于检测各对象的持有者是否存在。</p>
<p><code>autorelease：</code></p>
<p>类似于C语言中自动变量（局部变量）的特性（若某自动变量超出其作用域，则其被自动废弃），超出作用域，release 方法会被调用，但编程人员可以设定变量的作用域</p>
<p>[pool drain] 等同于 [obj release]</p>
<p>使用方法：</p>
<p>生成并持有 NSAutoreleasePool<br>调用已分配对象的 autorelease 实例方法<br>废弃 NSAutoreleasePool 对象</p>
<p><code>autorelease GNUstep 实现：</code></p>
<pre><code>//NSObject.m
-（id）autorelease {
    [NSAutoreleasePool addObject:self];
}


//NSAutoreleasePool.m
+ (void)addObject:(id)anObj {
    NSAutpreleasePool *pool = 取得正在使用的NSAutoreleasePool 对象
    if (pool != nil) {
        [pool addObject:anObj];
    } else {
        NSLog(@&quot;NSAutoreleasePool 对象非存在状态下调用autorelease&quot;);
    }
}

- (void)addObject:(id)anObj {
    [array addObject:anObj];
}

- (void)drain {
    [self dealloc];
}
- (void)dealloc {
    [self emptyPool];
    [array release];
}
- (void)emptyPool {
    for (id obj in array) {
        [obj release];
    }
}    
</code></pre><p><code>autorelease 苹果实现：</code></p>
<pre><code>class AutoreleasePoolPage {
    static inline void *push() {
        //相当于生成或持有 NSAutoreleasePool 类对象
    }
    static inline void *pop(void *token) {
        //相当于废弃 NSAutoreleasePool 类对象
        releaseAll();
    }
    static inline id autorelease(id obj) {
        // 相当于NSAutoreleasePool 类的 addObject 类方法
        AutoreleasePoolPage *autoreleasePoolPage = 
        取得正在使用的 AutoreleasePoolPage 实例；
        autpreleasePoolPage-&gt;add(obj);
    }
    id *add(id obj) {
        //将对象追加到内部数组中；            
    }
    void releaseAll {
        //调用内部数组中对象的release 实例方法；
    }
}
void *objc_autoreleasePoolPush(void) { 
    return AutoreleasePoolPage::push();
}
void *objc_autoreleasePoolPop(void *ctxt) {
    AutoreleasePoolPage::pop(ctxt);
}
id *objc_autprelease(id obj) {
    return  AutoreleasePoolPage::autorelease(obj);
}
</code></pre><p>NSAutoreleasePool 类的 showPools 类方法只能在 iOS 使用。在现在的运行时系统中，调试使用非公开函数_objc_autoreleasePoolPrint()</p>
<pre><code>// 函数声明
extern void _objc_autoreleasePoolPrint();

// 调用输出
_objc_autoreleasePoolPrint();
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<blockquote>
<p>学习笔记 一 之《Objective-C高级编程 iOS与OS X多线程和内存管理》</p>
</blockquote>
<h5 id="u7B2C_u4E00_u7AE0_uFF1A_u81EA_u52A8_u5F15_u7528_u8BA1_u6570"><a href="#u7B2C_u4E00_u7AE0_uFF1A_u81EA_u52A8_u5F15_u7528_u8BA1_u6570" class="headerlink" title="第一章：自动引用计数"></a>第一章：自动引用计数</h5><p><strong>内存管理/引用计数</strong></p>
<p><code>ARC 使用条件：</code></p>
<p>Xcode4.2，LLVM3.0，编译器设置 ARC 有效</p>
<p><code>引用计数：</code></p>
<p>1.自己生成的对象，自己所持有（alloc，new，copy，mutableCopy，allocMyObject，newThatObject，copyThis，mutableCopyYourObject）:</p>
<ul>
<li>alloc：自己生成并持有对象</li>
<li>new：自己生成并持有对象</li>
<li>copy：利用 NSCopying，各类实现 copyWithZone: 生成并持有对象的副本</li>
<li>mutableCopy：利用 NSMutableCopying,各类实现 mutableCopyWithZone: 生成并持有对象的副本</li>
</ul>]]>
    
    </summary>
    
      <category term="Objective-C高级编程 iOS与OS X多线程和内存管理" scheme="http://yoursite.com/tags/Objective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-iOS%E4%B8%8EOS-X%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[提交开发效率的工具和插件]]></title>
    <link href="http://yoursite.com/2016/02/22/%E6%8F%90%E4%BA%A4%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2016/02/22/提交开发效率的工具和插件/</id>
    <published>2016-02-22T10:42:25.000Z</published>
    <updated>2016-03-15T09:53:17.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<h4 id="Xcode_u63D2_u4EF6"><a href="#Xcode_u63D2_u4EF6" class="headerlink" title="Xcode插件"></a>Xcode插件</h4><ul>
<li><p>1.Alcatraz,管理Xcode插件<br><a href="https://github.com/alcatraz/Alcatraz" target="_blank" rel="external">https://github.com/alcatraz/Alcatraz</a></p>
</li>
<li><p>2.Auto-Importer,快速导入头文件<br><a href="https://github.com/citrusbyte/Auto-Importer-for-Xcode" target="_blank" rel="external">https://github.com/citrusbyte/Auto-Importer-for-Xcode</a></p>
</li>
<li><p>3.Backlight,高亮显示正在编辑的行<br><a href="https://github.com/limejelly/Backlight-for-XCode" target="_blank" rel="external">https://github.com/limejelly/Backlight-for-XCode</a></p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>4.DerivedData Exterminator,一键删除Derived Data<br><a href="https://github.com/kattrali/deriveddata-exterminator" target="_blank" rel="external">https://github.com/kattrali/deriveddata-exterminator</a></p>
</li>
<li><p>5.DXXcodeConsoleUnicodePlugin,转换 Xcode 控制台中一些不可阅读的字符。<br><a href="https://github.com/dhcdht/DXXcodeConsoleUnicodePlugin" target="_blank" rel="external">https://github.com/dhcdht/DXXcodeConsoleUnicodePlugin</a></p>
</li>
<li><p>6.FuzzyAutocompletePlugin,代码补全支持模糊查询<br><a href="https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin" target="_blank" rel="external">https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin</a></p>
</li>
<li><p>7.GitDiff,简单直观的标记本次commit修改的部位<br><a href="https://github.com/johnno1962/GitDiff" target="_blank" rel="external">https://github.com/johnno1962/GitDiff</a></p>
</li>
<li><p>8.VVDocumenter,三道杠添加文档注释<br><a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="external">https://github.com/onevcat/VVDocumenter-Xcode</a></p>
</li>
<li><p>9.SCXcodeMiniMap,右边显示小地图<br><a href="https://github.com/stefanceriu/SCXcodeMiniMap" target="_blank" rel="external">https://github.com/stefanceriu/SCXcodeMiniMap</a></p>
</li>
<li><p>10.KSImageNamed,用图片时自动显示图片缩略图<br><a href="https://github.com/ksuther/KSImageNamed-Xcode" target="_blank" rel="external">https://github.com/ksuther/KSImageNamed-Xcode</a></p>
</li>
<li><p>11.SCXcodeSwitchExpander,switch枚举的时候会自动生成代码<br><a href="https://github.com/stefanceriu/SCXcodeSwitchExpander" target="_blank" rel="external">https://github.com/stefanceriu/SCXcodeSwitchExpander</a></p>
</li>
</ul>
<h4 id="Mac_u5DE5_u5177"><a href="#Mac_u5DE5_u5177" class="headerlink" title="Mac工具"></a>Mac工具</h4><ul>
<li><p>1.Network Link Conditioner,模拟不同网环境<br><a href="http://blog.csdn.net/chun799/article/details/7887377" target="_blank" rel="external">http://blog.csdn.net/chun799/article/details/7887377</a></p>
</li>
<li><p>2.Charles,Mac上的抓包工具Charles<br><a href="http://blog.csdn.net/jiangwei0910410003/article/details/41620363" target="_blank" rel="external">http://blog.csdn.net/jiangwei0910410003/article/details/41620363</a></p>
</li>
<li><p>3.iSwift for Mac,Objective-C转换Swift代码工具<br><a href="http://www.waitsun.com/iswift-2-0.html" target="_blank" rel="external">http://www.waitsun.com/iswift-2-0.html</a></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<h4 id="Xcode_u63D2_u4EF6"><a href="#Xcode_u63D2_u4EF6" class="headerlink" title="Xcode插件"></a>Xcode插件</h4><ul>
<li><p>1.Alcatraz,管理Xcode插件<br><a href="https://github.com/alcatraz/Alcatraz">https://github.com/alcatraz/Alcatraz</a></p>
</li>
<li><p>2.Auto-Importer,快速导入头文件<br><a href="https://github.com/citrusbyte/Auto-Importer-for-Xcode">https://github.com/citrusbyte/Auto-Importer-for-Xcode</a></p>
</li>
<li><p>3.Backlight,高亮显示正在编辑的行<br><a href="https://github.com/limejelly/Backlight-for-XCode">https://github.com/limejelly/Backlight-for-XCode</a></p>
</li>
</ul>]]>
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="效率" scheme="http://yoursite.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Storyboard复杂 UI 处理汇总]]></title>
    <link href="http://yoursite.com/2016/01/08/Storyboard%E5%A4%8D%E6%9D%82-UI-%E5%A4%84%E7%90%86%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2016/01/08/Storyboard复杂-UI-处理汇总/</id>
    <published>2016-01-08T08:47:21.000Z</published>
    <updated>2016-03-15T09:56:47.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<p>当我们在用 Storyboard 设计一些复杂的 UI 时，总觉得不是很好处理，约束不太容易正确添加。以下是我在这方面遇到的一些问题及找到的处理方法：</p>
<h3 id="u5728UIScrollView_u4E2D_u5D4C_u5957_u591A_u4E2ATableView_3A"><a href="#u5728UIScrollView_u4E2D_u5D4C_u5957_u591A_u4E2ATableView_3A" class="headerlink" title="在UIScrollView中嵌套多个TableView:"></a>在UIScrollView中嵌套多个TableView:</h3><p><a href="http://www.jianshu.com/p/bad9bde9b81e" target="_blank" rel="external">http://www.jianshu.com/p/bad9bde9b81e</a><br>文中 demo 是基于 Swift 语言做的（还好我刚把 Swift 语法看完，能看懂 demo.😉）</p>
<a id="more"></a>
<p><br></p>
<font color="brown"><strong>对其补充：</strong></font>

<p>若是页面需要导航栏，第一次进入页面时，第一个 table 会下陷64个像素，上下滑动列表后，回到导航条下面的位置。而第二个table 从最上面向下拉时，scorllview 显示偏移 x = 0 的的位置。<br>在代码中添加以下代码，可解决这些问题<br><br></p>
<font color="green"><strong>解决方案：</strong></font>

<pre><code>self.edgesForExtendedLayout = UIRectEdgeNone
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<p>当我们在用 Storyboard 设计一些复杂的 UI 时，总觉得不是很好处理，约束不太容易正确添加。以下是我在这方面遇到的一些问题及找到的处理方法：</p>
<h3 id="u5728UIScrollView_u4E2D_u5D4C_u5957_u591A_u4E2ATableView_3A"><a href="#u5728UIScrollView_u4E2D_u5D4C_u5957_u591A_u4E2ATableView_3A" class="headerlink" title="在UIScrollView中嵌套多个TableView:"></a>在UIScrollView中嵌套多个TableView:</h3><p><a href="http://www.jianshu.com/p/bad9bde9b81e">http://www.jianshu.com/p/bad9bde9b81e</a><br>文中 demo 是基于 Swift 语言做的（还好我刚把 Swift 语法看完，能看懂 demo.😉）</p>]]>
    
    </summary>
    
      <category term="Storyboard" scheme="http://yoursite.com/tags/Storyboard/"/>
    
      <category term="UIScrollView" scheme="http://yoursite.com/tags/UIScrollView/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016年计划]]></title>
    <link href="http://yoursite.com/2015/12/23/2016%E5%B9%B4%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2015/12/23/2016年计划/</id>
    <published>2015-12-23T04:13:56.000Z</published>
    <updated>2016-03-15T09:55:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<h3 id="u77E5_u8BC6_uFF1A"><a href="#u77E5_u8BC6_uFF1A" class="headerlink" title="知识："></a>知识：</h3><ul>
<li>金融 </li>
<li>理财</li>
</ul>
<h3 id="u6280_u672F"><a href="#u6280_u672F" class="headerlink" title="技术"></a>技术</h3><ul>
<li>继续写文章</li>
<li>Swift</li>
<li>Python，学习运维知识</li>
<li>手表开发（Watch OS，Swift）</li>
<li>研究 OC 底层和 Swift 底层。</li>
</ul>
<a id="more"></a>
<h3 id="u8BFB_u4E66"><a href="#u8BFB_u4E66" class="headerlink" title="读书"></a>读书</h3><p>至少每月2本书：2 * 12 = 24，每本书都要写读后感，总结</p>
<ul>
<li>手中的4本技术书</li>
<li>每个月去一次图书馆，一次借2本书</li>
</ul>
<h3 id="u4EA4_u53CB"><a href="#u4EA4_u53CB" class="headerlink" title="交友"></a>交友</h3><p>至少一位知心朋友</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<h3 id="u77E5_u8BC6_uFF1A"><a href="#u77E5_u8BC6_uFF1A" class="headerlink" title="知识："></a>知识：</h3><ul>
<li>金融 </li>
<li>理财</li>
</ul>
<h3 id="u6280_u672F"><a href="#u6280_u672F" class="headerlink" title="技术"></a>技术</h3><ul>
<li>继续写文章</li>
<li>Swift</li>
<li>Python，学习运维知识</li>
<li>手表开发（Watch OS，Swift）</li>
<li>研究 OC 底层和 Swift 底层。</li>
</ul>]]>
    
    </summary>
    
      <category term="计划" scheme="http://yoursite.com/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="个人" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015年总结]]></title>
    <link href="http://yoursite.com/2015/12/23/2015%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2015/12/23/2015年总结/</id>
    <published>2015-12-23T04:09:53.000Z</published>
    <updated>2016-03-15T09:55:21.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<blockquote>
<p>人生天地之间,若白驹之过郤(隙),忽然而已.————《庄子·知北游》</p>
</blockquote>
<p><br><br>光阴似箭，日月如梭，转眼间2015年仅剩几个日夜。</p>
<p>从12年11月29号开始接触 iOS 开发，到现在也3年时间了。一直浑浑噩噩的过着上班工作，下班休息，既无总结也无规划的日子。最近突然间想写写自己在15年做了些什么，学到了些什么，并计划下下一年度的任务和目标。</p>
<a id="more"></a>
<h3 id="u5DE5_u4F5C"><a href="#u5DE5_u4F5C" class="headerlink" title="工作"></a>工作</h3><p>14年12月1号进入了一家关于生活美学指南的电商公司（下文的公司 A），一直维护一份之前的开发人员在12年写的代码。项目对体验要求比较高（然而这并未提升我个人的审美标准 ಥ_ಥ），UI 设计师对做出的效果很上心，不容差错一个像素，但不可不说其设计的效果是非常棒的。</p>
<p>在A公司工作，了解到了电商 app 的特色和注意事项，如：</p>
<ul>
<li>库存的计算是比较麻烦的，尤其是对于那些有多个颜色，多个尺寸的商品。</li>
<li>购物车中商品可能有多个状态，有无库存，参不参加满减的活动。</li>
<li>下完订单后支付后状态可能由于各种原因(尤其是与第三方支付平台的对接)造成显示不正确</li>
</ul>
<p>当然，最复杂的逻辑还是在后台，客户端展示不出异常就OK了</p>
<p>15年8月份的时候跳槽至现在所在的这家互联网金融公司 (下文的公司 B)，当时对金融也是比较感兴趣的，希望能进入到互联网金融工作，所以，对这份 offer 很满意（虽然薪资不是很高-_-）。</p>
<p>在 B公司，开始也是维护前辈写的项目，做的功能不多，新加了指纹解锁功能和部分日夜模式切换的功能。</p>
<p>9月份的时候开始做新项目。新项目是团队协作，与以往不一样，之前做新项目，都是自己一个人做；新项目，采用了比较简便的可视化布局Srotyboard，之前做项目，一直是代码写 UI。慢慢的学会了用可视化布局 UI,并且可是很熟练的使用约束，无需写代码就可以控制控件的相对位置，适配不同尺寸的屏幕，这对自己来说真真的是很大进步。这当然离不开我的好同事们（给他们一个大大的赞~_~）。</p>
<p>B公司的项目都是金融方面相关的，这令我我学到了不少金融方面的知识，如：学会了看K线图的行情，并了解它是如何实现（K线相关的都是前同事做的，我只是做了迁移，站在巨人的肩膀上）。</p>
<h3 id="u4E2A_u4EBA_u53D1_u5C55"><a href="#u4E2A_u4EBA_u53D1_u5C55" class="headerlink" title="个人发展"></a>个人发展</h3><p>15年其实没看多少书，由于在考项目管理本科，也只是看了考试相关的几本。14年6月开始准备同年10月份考试，学习了：项目采购和合同，项目管理软技术；15年4月考试，学习了：项目时间管理，项目成本管理，企业项目管理，项目管理学；15年10月考试，学习了：项目风险管理，项目范围管理，中国近代史</p>
<p>技术方面的书，看了唐巧的《iOS开发进阶》的 pdf 版。以前也不怎么看纸质版的书，买了有3，4本的iOS 开发相关的书，基本没怎么认真的翻阅过。故打算在16年先把手里有的书本从头到尾翻阅一遍。</p>
<p>15年9月开始写文章，记录自己在工作过程中的一些问题和解决过程。</p>
<h3 id="u56DE_u987E_u603B_u7ED3"><a href="#u56DE_u987E_u603B_u7ED3" class="headerlink" title="回顾总结"></a>回顾总结</h3><p>工作这些年，也没怎么好好的总结过，现在回顾下，感觉自己只是白白添了岁数，浪费了一年又的光阴。所以，计划16年多读点书，多学点技术，顺便要改变下自己的性格，至少交一位知心的朋友。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<blockquote>
<p>人生天地之间,若白驹之过郤(隙),忽然而已.————《庄子·知北游》</p>
</blockquote>
<p><br><br>光阴似箭，日月如梭，转眼间2015年仅剩几个日夜。</p>
<p>从12年11月29号开始接触 iOS 开发，到现在也3年时间了。一直浑浑噩噩的过着上班工作，下班休息，既无总结也无规划的日子。最近突然间想写写自己在15年做了些什么，学到了些什么，并计划下下一年度的任务和目标。</p>]]>
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="个人" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 hexo 搭建博客]]></title>
    <link href="http://yoursite.com/2015/12/23/%E4%BD%BF%E7%94%A8-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2015/12/23/使用-Hexo-搭建博客/</id>
    <published>2015-12-23T03:39:45.000Z</published>
    <updated>2016-03-15T09:55:55.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<h4 id="u914D_u7F6E_u73AF_u5883"><a href="#u914D_u7F6E_u73AF_u5883" class="headerlink" title="配置环境"></a>配置环境</h4><p> 安装 homebrew：</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre><p>安装node.js：</p>
<pre><code>brew install node
</code></pre><p>安装 hexo:</p>
<pre><code>npm install hexo -g
</code></pre><a id="more"></a>
<p>执行init命令初始化hexo到你指定的目录</p>
<pre><code>hexo init &lt;folder&gt;
</code></pre><p>进入文件夹</p>
<pre><code>cd &lt;folder&gt;
</code></pre><p>然后运行</p>
<pre><code>npm install //这句应该用不到
</code></pre><p>自动根据当前目录下文件,生成静态网页</p>
<pre><code>hexo generate
</code></pre><p>运行本地服务</p>
<pre><code>hexo server 
</code></pre><p>Done！<br><a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></p>
<p>//停止本地服务：Press Ctrl+C to stop</p>
<p><br></p>
<h4 id="u6DFB_u52A0_u6587_u7AE0"><a href="#u6DFB_u52A0_u6587_u7AE0" class="headerlink" title="添加文章"></a>添加文章</h4><p>创建文章文件名</p>
<pre><code>hexo new &quot;&quot;
</code></pre><p>生成静态网页</p>
<pre><code>hexo generate
</code></pre><p>运行本地服务</p>
<pre><code>hexo server
</code></pre><h3 id="u90E8_u7F72_u5230_Github"><a href="#u90E8_u7F72_u5230_Github" class="headerlink" title="部署到 Github"></a>部署到 Github</h3><p>这篇文章很详细<br><a href="http://jingyan.baidu.com/article/d8072ac47aca0fec95cefd2d.html" target="_blank" rel="external">http://jingyan.baidu.com/article/d8072ac47aca0fec95cefd2d.html</a></p>
<h6 id="u5173_u952E_u5DE5_u4F5C"><a href="#u5173_u952E_u5DE5_u4F5C" class="headerlink" title="关键工作"></a>关键工作</h6><p>配置 _config.yml 文件</p>
<pre><code>deploy:
 type: git
 repository: https://github.com/XXXXXX/XXXXXX.github.io.git
 branch: master
</code></pre><p>生成网页</p>
<pre><code>hexo generate
</code></pre><p>部署</p>
<pre><code>hexo deploy
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<h4 id="u914D_u7F6E_u73AF_u5883"><a href="#u914D_u7F6E_u73AF_u5883" class="headerlink" title="配置环境"></a>配置环境</h4><p> 安装 homebrew：</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre><p>安装node.js：</p>
<pre><code>brew install node
</code></pre><p>安装 hexo:</p>
<pre><code>npm install hexo -g
</code></pre>]]>
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://yoursite.com/2015/12/23/hello-world/"/>
    <id>http://yoursite.com/2015/12/23/hello-world/</id>
    <published>2015-12-23T03:13:33.000Z</published>
    <updated>2016-03-14T04:24:39.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>]]>
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSLayoutConstraint 的妙用(贵金属）]]></title>
    <link href="http://yoursite.com/2015/12/22/NSLayoutConstraint-%E7%9A%84%E5%A6%99%E7%94%A8-%E8%B4%B5%E9%87%91%E5%B1%9E%EF%BC%89/"/>
    <id>http://yoursite.com/2015/12/22/NSLayoutConstraint-的妙用-贵金属）/</id>
    <published>2015-12-22T04:01:35.000Z</published>
    <updated>2016-03-15T09:56:30.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<p>贵金属项目，是第一次使用 storyboard 开发，以下是初次接触 NSLayoutConstraint，遇到的问题：</p>
<a id="more"></a>
<h4 id="u95EE_u98981_uFF1A"><a href="#u95EE_u98981_uFF1A" class="headerlink" title="问题1："></a>问题1：</h4><p>用 storyboard 搭建的 UI，在 tableView 的 header 中的控件的高度是不固定的，条件1下控件高90，条件2下控件高45,所以就考虑用代码控制控件的高度。</p>
<p>在用代码设置了控件的高度和 header 的高度后，发现效果并非如预期所想。在 storyboard 里面设置了90，在代码中设置了45，显示时还是90，代码更改高度没变化。</p>
<p><font color="brown"><strong>原因：</strong></font>UIButton 的 buttonType<br>在 storyboard 里面设置了控件的高度，并且添加了约束，其中便有高度的约束，约束有了，代码更改控件的高度，并不会有效果。</p>
<p><font color="green"><strong>解决方案：</strong></font><br>NSLayoutConstraint 是可以设置成属性的，在 storyboard 中添加控件高度约束的属性的连线，连接到相对应的文件中。在文件中更改该属性的值，如下：</p>
<pre><code>@property (weak, nonatomic) IBOutlet NSLayoutConstraint *surplusHeightLayout;


self.surplusHeightLayout.constant = 45;
</code></pre><h4 id="u95EE_u98982_uFF1A"><a href="#u95EE_u98982_uFF1A" class="headerlink" title="问题2："></a>问题2：</h4><p>用 storyboard 搭建的 UI，控件之间有分割线，UI设计师设计的是1像素，所以需要设置0.5高。但是在Xcode7 的 storyboard 中无法设置带有”.5”的数字。虽然可以像上面的问题的解决方案那样处理，可以达到效果，但是分割线太多，那样处理工作量太大，还会有很多冗余的代码。</p>
<p><font color="green"><strong>解决方案：</strong></font><br> 创建 NSLayoutConstraint 的子类NSLayoutConstraintHairline，在.m 中添加以下代码：</p>
<pre><code>- (void)awakeFromNib {
    [super awakeFromNib];
    if (self.constant == 1) {
       self.constant = 0.5/[UIScreen mainScreen].scale;
    }
}
</code></pre><p>在 storyboard 中设置分割线的高为任意值，选中分割线的高的约束，修改其类型NSLayoutConstraint为创建的NSLayoutConstraintHairline即可达到目的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<p>贵金属项目，是第一次使用 storyboard 开发，以下是初次接触 NSLayoutConstraint，遇到的问题：</p>]]>
    
    </summary>
    
      <category term="贵金属" scheme="http://yoursite.com/tags/%E8%B4%B5%E9%87%91%E5%B1%9E/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Bug 小记（贵金属）]]></title>
    <link href="http://yoursite.com/2015/11/20/Bug-%E5%B0%8F%E8%AE%B0%EF%BC%88%E8%B4%B5%E9%87%91%E5%B1%9E%EF%BC%89/"/>
    <id>http://yoursite.com/2015/11/20/Bug-小记（贵金属）/</id>
    <published>2015-11-20T03:13:33.000Z</published>
    <updated>2016-03-15T11:52:10.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<p>最近在修复 APP 的 Bug，遇到了几个因对 SDK 不熟 造成的 Bug。如下：<br><br></p>
<a id="more"></a>
<p><strong>Bug1：点击获取验证码后，没有进行倒计时，且不能再次点击</strong></p>
<p>使用 GCD 写的倒计时，源代码：</p>
<pre><code>_isCountDown = YES;
__block int timeout=kCountdownTime; //倒计时时间
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);
dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行
dispatch_source_set_event_handler(_timer, ^{
    if(timeout&lt;=0){ //倒计时结束，关闭
        dispatch_source_cancel(_timer);
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.getSmsCodeBtn setTitle:@&quot;重新获取&quot; forState:UIControlStateNormal];

            [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_LOGINBTN_AVAILABLE_NORMAL) forState:UIControlStateNormal];

            [self.getSmsCodeBtn setEnabled:YES];
            _isCountDown = NO;
        });
    }else{
        NSString *strTime = [NSString stringWithFormat:@&quot;%ds后重发&quot;,timeout];
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateNormal];

            [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_GETCODEBTN_UNAVAILABLE) forState:UIControlStateNormal];
        });
        timeout--;

    }
});
dispatch_resume(_timer);
</code></pre><p>如上所示的源码，在 iOS7 上倒计时按钮上的文字不会变化，在 iOS 8,iOS9 上都是没问题的，我也郁闷了很久。各种百度未果后转向 Google,也有人遇到这样的问题，但是只搜索到一篇真正能解决这个问题的文章 <a href="http://blog.csdn.net/zhangyanshen/article/details/46910515" title="http://blog.csdn.net/zhangyanshen/article/details/46910515" target="_blank" rel="external">http://blog.csdn.net/zhangyanshen/article/details/46910515</a></p>
<font color="green"><strong>解决方案：</strong></font>

<pre><code>[sendAuthCodeBtn setTitle:@&quot;发送验证码&quot; forState:UIControlStateDisabled]; 
</code></pre><p>关键在于这行代码。设置了禁用状态下的文字。顺利解决了 这个 Bug。<br><br></p>
<p><strong>Bug2：倒计时 UIButton 上的文字变更会有闪烁效果</strong></p>
<p>UIButton 设置 title时会闪烁。</p>
<font color="brown"><strong>原因：</strong></font>UIButton 的 buttonType 是 System 类型时会出现该种问题<br><br><font color="green"><strong>解决方案：</strong></font>UIButton 的 buttonType 设置为 Custom 类型时不会出现闪烁。<br><br><br><br><strong>Bug3：在工程中添加plist 文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变</strong><br><br>plist 文件中是一个数组，元素是多个字典，在模拟器上运行一切正常，但测试人员用真机测试时发现问题，无法写入到 plist 文件中。<br><br><font color="brown"><strong>原因：</strong></font> 打包在 ipa 的文件是无法更改的。一句话：无权限修改（知道真相的我眼泪掉下来~)，只可进行读取操作。<br><br><font color="green"><strong>解决方案：</strong></font>在 app 启动的时候判断是否在 Document 文件夹下存在相同的 plsit 文件。 不存在，获取沙盒下 plist 文件中的内容，并写入Document 文件夹下的 plsit 文件。存在则不做任何处理。（之所以选择这种方式而不选择直接将内容用代码写入 Document 文件夹下来解决这个问题，是因为个人认为在开发时方便对工程中plsit 文件内容的更改）<br><br><br><br><font color="pinkw"><strong>更新时间：2016年1月20日</strong></font>

<p><strong>Bug1：进入某个页面，App崩溃，崩溃原因是：[NSCFType set]: unrecognized selector sent to instance 0x4d80b00’</strong></p>
<font color="brown"><strong>原因：</strong></font> 在新页面使用了NSMutableAttributedString，使用方式导致了崩溃，目前无法解释，使用方法如下：<br><br><br><code>NSMutableAttributedString *attriString =     [[NSMutableAttributedString alloc] initWithString:prodNameStr];
    [attriString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:16.0] range:NSMakeRange(2, 2)];
    [attriString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(2, 2)];</code><br><br><br><br><font color="green"><strong>解决方案：</strong></font>


<pre><code>NSMutableAttributedString *attriString = [[NSMutableAttributedString alloc] initWithString:prodNameStr];
[attriString setAttributes:@{NSFontAttributeName : [UIFont systemFontOfSize:12.0], NSForegroundColorAttributeName:ColorWithHexString(GJS_COLOR_TEXT_GRAY)} range:NSMakeRange(prodNameStr.length - time.length, time.length)];`
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<p>最近在修复 APP 的 Bug，遇到了几个因对 SDK 不熟 造成的 Bug。如下：<br></br></p>]]>
    
    </summary>
    
      <category term="Bug" scheme="http://yoursite.com/tags/Bug/"/>
    
      <category term="贵金属" scheme="http://yoursite.com/tags/%E8%B4%B5%E9%87%91%E5%B1%9E/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[指纹解锁]]></title>
    <link href="http://yoursite.com/2015/09/16/%E6%8C%87%E7%BA%B9%E8%A7%A3%E9%94%81/"/>
    <id>http://yoursite.com/2015/09/16/指纹解锁/</id>
    <published>2015-09-16T03:39:45.000Z</published>
    <updated>2016-03-15T09:56:06.000Z</updated>
    <content type="html"><![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<p>iOS8 指纹解锁的API，<a href="http://www.bubuko.com/infodetail-726115.html" target="_blank" rel="external">这篇文章</a>解释的非常清楚。  </p>
<p>本文主要针对在实际使用中遇到的问题及解决方法，假定已经了解指纹解锁API，如不了解API,请先移步<a href="http://www.bubuko.com/infodetail-726115.html" target="_blank" rel="external">指纹解锁的API说明</a></p>
<p>项目之前一直使用的是手势密码，近来要增加 iOS8 新出的指纹解锁功能。需求是在设置中添加指纹解锁开关 </p>
<a id="more"></a>
<h4 id="u95EE_u98981_uFF1A"><a href="#u95EE_u98981_uFF1A" class="headerlink" title="问题1："></a>问题1：</h4><p>在个人设置里面，添加指纹解锁开关项，此项仅在支持TouchID 的设备中出现<br>很好，百度了下，得到了如下解决方案  </p>
<font color="green"><strong>解决方案：</strong></font>


<pre><code>LAContext *context = [LAContext new];
NSError *error = [NSError new];
BOOL isAvailable = [context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error];
</code></pre><p>这是api给出的判断TouchID是否可用的方法，isAvailable == Yes 说明 TouchID 可用，反之，则不可用。<br>但是，当我满心欢喜的使用的时候，问题来了</p>
<h4 id="u95EE_u98982_uFF1A"><a href="#u95EE_u98982_uFF1A" class="headerlink" title="问题2："></a>问题2：</h4><p>在6 Plus，未设置手机解锁密码或没有可用的指纹时，用上面的方法判断 isAvailable == No,瞬间心都碎了。<br>这里依然有解决方案</p>
<font color="green"><strong>解决方案：</strong></font>

<pre><code>if (!isAvailable) {
    NSString *str = nil;
    switch (error.code) {
           case LAErrorTouchIDNotEnrolled://无可用指纹

        case LAErrorPasscodeNotSet://设备未开启密码
        {
            isAvailable = YES;
            break;
        }
        case LAErrorTouchIDNotAvailable:
        default:
        {
            isAvailable = NO;
            break;
        }

    }
}
</code></pre><p>虽然依然把这个问题解决了。but，又产生了新的问题。</p>
<h4 id="u95EE_u98983_uFF1A"><a href="#u95EE_u98983_uFF1A" class="headerlink" title="问题3："></a>问题3：</h4><p>使用上述方法，在 iPod Touch 等不支持 TouchID 的设备，未设置手机解锁密码情况下运行时，设置中的指纹解锁开关项居然出现了。</p>
<p>单步调试之，在 error.code 的 switch 中，进入的是 case LAErrorPasscodeNotSet://设备未开启密码，执行了isAvailable = YES;。然，大胆猜测之，api 居然先判断的是有没有开启密码而不是设备类型和或系统是否支持，这使我彻底无语~~~~</p>
<p>此时，我再也不相信API了，果断自己写判断吧。</p>
<font color="green"><strong>解决方案：</strong></font>


<pre><code>// 硬件设备不支持，或系统版本不支持 指纹解锁
if (![Utils isSystemModelSupportTouchID] || ![Utils isSystemVersionMoreThanVersion:7.0]) {
    return NO;
}

LAContext *context = [LAContext new];
NSError *error = [NSError new];
BOOL isDeviceSupportTouchId = [context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error];

if (!isDeviceSupportTouchId) {

    //不支持指纹识别

    switch (error.code) {

        case LAErrorTouchIDNotEnrolled:

        case LAErrorPasscodeNotSet:
        {
            isDeviceSupportTouchId = YES;
            break;
        }
        case LAErrorTouchIDNotAvailable:
        default:
        {
            isDeviceSupportTouchId = NO;
            break;
        }
    }
}


return isDeviceSupportTouchId;
</code></pre><p>硬件设备判断上花了一小点功夫，版本判断显然很简单。</p>
<p><strong>硬件设备判断思路：</strong></p>
<p>1.获取设备类型字符串，如iPhone 5c,iPhone 6；<br>2.判断设备类型字符串是包含iPhone ,iPod , iPad，是iPhone 则截取设备类型字符串中的第一位数字，iPad 有分mini 和Air, 截取设备类型字符串中的第一位数字，然后数字对比判断是否支持TouchID。</p>
<p>至此，TouchID 告一段落！在此，附上本文中的 Demo 地址：<a href="https://github.com/mohuifen/LRFFingerPrintManager" target="_blank" rel="external">LRFFingerPrintManager</a>,欢迎各位读者朋友提出建议。。</p>
<p><br></p>
<hr>
<hr>
<hr>
<p><br><br><strong>时间：2015年12月23日</strong></p>
<p><br><br>最近 iOS9.2 系统正式发布，有反应说App中使用指纹解锁在 iOS9.2 上会导致App崩溃。故，开始了查找 bug 之旅。</p>
<h4 id="u95EE_u98984_uFF1A"><a href="#u95EE_u98984_uFF1A" class="headerlink" title="问题4："></a>问题4：</h4><p>升级手机9.2 版本后，使用指纹解锁，果然是崩溃了。手指放到 home 键上后，App 卡死，无法点击页面上的控件，大概3，4秒后闪退至桌面。</p>
<p>由于测试机都没有升级，故先看了相关的代码，注意到在验证指纹成功后，                使用dispatch_sync(dispatch_get_main_queue(), ^{ }）来调用主线程处理一些工作。遂，猜想应该是这里出了问题，一般应使用dispatch_async,而非dispatch_sync。但不敢肯定，因为无法解释这样写就会崩溃，而且之前一直都是可以正常使用的。</p>
<font color="brown"><strong>原因：</strong></font><br>iOS9.2 做了优化，使体验更流畅。可能在dispatch_async和dispatch_sync下了刀。<br><br><font color="green"><strong>解决方案：</strong></font>

<p>待用9.2系统的真机运行时，半信半疑的把其改用了dispatch_async，并没有崩溃。但使用dispatch_sync确实崩溃了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>作者：秋儿（lvruifei@foxmail.com）</strong></p>
<p>iOS8 指纹解锁的API，<a href="http://www.bubuko.com/infodetail-726115.html">这篇文章</a>解释的非常清楚。  </p>
<p>本文主要针对在实际使用中遇到的问题及解决方法，假定已经了解指纹解锁API，如不了解API,请先移步<a href="http://www.bubuko.com/infodetail-726115.html">指纹解锁的API说明</a></p>
<p>项目之前一直使用的是手势密码，近来要增加 iOS8 新出的指纹解锁功能。需求是在设置中添加指纹解锁开关 </p>]]>
    
    </summary>
    
      <category term="指纹解锁" scheme="http://yoursite.com/tags/%E6%8C%87%E7%BA%B9%E8%A7%A3%E9%94%81/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
  </entry>
  
</feed>